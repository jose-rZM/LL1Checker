<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LL1Checker: LL1Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LL1Checker<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">“Tool for verifying LL(1) grammars and validating input strings.”</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classLL1Parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LL1Parser Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a419899deba2324f6018dff5aa8f1c933" id="r_a419899deba2324f6018dff5aa8f1c933"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a419899deba2324f6018dff5aa8f1c933">LL1Parser</a> (<a class="el" href="structGrammar.html">Grammar</a> gr, std::string text_file, bool table_format=true)</td></tr>
<tr class="memdesc:a419899deba2324f6018dff5aa8f1c933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classLL1Parser.html">LL1Parser</a> with a grammar object and an input file.  <br /></td></tr>
<tr class="separator:a419899deba2324f6018dff5aa8f1c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573b8200f9a1dce0e22caa9ea633c4a1" id="r_a573b8200f9a1dce0e22caa9ea633c4a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573b8200f9a1dce0e22caa9ea633c4a1">LL1Parser</a> (const std::string &amp;grammar_file, std::string text_file, bool table_format=true)</td></tr>
<tr class="memdesc:a573b8200f9a1dce0e22caa9ea633c4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classLL1Parser.html">LL1Parser</a> with a grammar file and an input file.  <br /></td></tr>
<tr class="separator:a573b8200f9a1dce0e22caa9ea633c4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3644ed0d218effcaa8ac25ef329a5d5" id="r_ac3644ed0d218effcaa8ac25ef329a5d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3644ed0d218effcaa8ac25ef329a5d5">LL1Parser</a> (const std::string &amp;grammar_file, bool table_format=true)</td></tr>
<tr class="memdesc:ac3644ed0d218effcaa8ac25ef329a5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classLL1Parser.html">LL1Parser</a> with a grammar file.  <br /></td></tr>
<tr class="separator:ac3644ed0d218effcaa8ac25ef329a5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658cc49bf42de998962dba95c06ee2ab" id="r_a658cc49bf42de998962dba95c06ee2ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658cc49bf42de998962dba95c06ee2ab">Parse</a> ()</td></tr>
<tr class="memdesc:a658cc49bf42de998962dba95c06ee2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an input string or file using the LL(1) parsing algorithm.  <br /></td></tr>
<tr class="separator:a658cc49bf42de998962dba95c06ee2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235e19d551647775130eddfd0661311b" id="r_a235e19d551647775130eddfd0661311b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235e19d551647775130eddfd0661311b">MatchTerminal</a> (const std::string &amp;top_symbol, const std::string &amp;current_symbol)</td></tr>
<tr class="memdesc:a235e19d551647775130eddfd0661311b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a terminal symbol from the stack with the current input symbol.  <br /></td></tr>
<tr class="separator:a235e19d551647775130eddfd0661311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1fa3255a089e2fa52a11b015490975" id="r_aed1fa3255a089e2fa52a11b015490975"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed1fa3255a089e2fa52a11b015490975">ProcessNonTerminal</a> (const std::string &amp;top_symbol, const std::string &amp;current_symbol)</td></tr>
<tr class="memdesc:aed1fa3255a089e2fa52a11b015490975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a non-terminal symbol by expanding it according to the LL(1) parsing table.  <br /></td></tr>
<tr class="separator:aed1fa3255a089e2fa52a11b015490975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964e6f48a2941f4925dd65f63f5123ca" id="r_a964e6f48a2941f4925dd65f63f5123ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a964e6f48a2941f4925dd65f63f5123ca">PrintTable</a> ()</td></tr>
<tr class="memdesc:a964e6f48a2941f4925dd65f63f5123ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the LL(1) parsing table to standard output.  <br /></td></tr>
<tr class="separator:a964e6f48a2941f4925dd65f63f5123ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b0f4b5c16280855395a00acab8489c" id="r_aa1b0f4b5c16280855395a00acab8489c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1b0f4b5c16280855395a00acab8489c">PrintStackTrace</a> ()</td></tr>
<tr class="memdesc:aa1b0f4b5c16280855395a00acab8489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the remaining symbols in the parsing stack after the parsing process.  <br /></td></tr>
<tr class="separator:aa1b0f4b5c16280855395a00acab8489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5975f1abae5c7a04e01d239bef27a0eb" id="r_a5975f1abae5c7a04e01d239bef27a0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5975f1abae5c7a04e01d239bef27a0eb">PrintSymbolHist</a> ()</td></tr>
<tr class="memdesc:a5975f1abae5c7a04e01d239bef27a0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the last kTraceSize symbols processed.  <br /></td></tr>
<tr class="separator:a5975f1abae5c7a04e01d239bef27a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa240d93c411bc895acadcfdd7abd0320" id="r_aa240d93c411bc895acadcfdd7abd0320"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa240d93c411bc895acadcfdd7abd0320">ll1_table</a></td></tr>
<tr class="separator:aa240d93c411bc895acadcfdd7abd0320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af556dd5a7357b97ec5d078983db62553" id="r_af556dd5a7357b97ec5d078983db62553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af556dd5a7357b97ec5d078983db62553">First</a> (std::span&lt; const std::string &gt; rule, std::unordered_set&lt; std::string &gt; &amp;result)</td></tr>
<tr class="memdesc:af556dd5a7357b97ec5d078983db62553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the FIRST set for a given production rule in a grammar.  <br /></td></tr>
<tr class="separator:af556dd5a7357b97ec5d078983db62553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f702d940802a8b02538cb173a6c7e5e" id="r_a2f702d940802a8b02538cb173a6c7e5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f702d940802a8b02538cb173a6c7e5e">ComputeFirstSets</a> ()</td></tr>
<tr class="memdesc:a2f702d940802a8b02538cb173a6c7e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the FIRST sets for all non-terminal symbols in the grammar.  <br /></td></tr>
<tr class="separator:a2f702d940802a8b02538cb173a6c7e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ee1f3ebc4cedacbb11204e3e8cbfdc" id="r_a02ee1f3ebc4cedacbb11204e3e8cbfdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02ee1f3ebc4cedacbb11204e3e8cbfdc">ComputeFollowSets</a> ()</td></tr>
<tr class="memdesc:a02ee1f3ebc4cedacbb11204e3e8cbfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the FOLLOW sets for all non-terminal symbols in the grammar.  <br /></td></tr>
<tr class="separator:a02ee1f3ebc4cedacbb11204e3e8cbfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44706610e5fad3f4d2fd437f64c8884b" id="r_a44706610e5fad3f4d2fd437f64c8884b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44706610e5fad3f4d2fd437f64c8884b">UpdateFollow</a> (const std::string &amp;symbol, const std::string &amp;lhs, const production &amp;rhs, size_t i)</td></tr>
<tr class="memdesc:a44706610e5fad3f4d2fd437f64c8884b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the FOLLOW set for a non-terminal based on a production.  <br /></td></tr>
<tr class="separator:a44706610e5fad3f4d2fd437f64c8884b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9dc60f3f6a8332b0ed727d4c8fd40f" id="r_a0f9dc60f3f6a8332b0ed727d4c8fd40f"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f9dc60f3f6a8332b0ed727d4c8fd40f">Follow</a> (const std::string &amp;arg)</td></tr>
<tr class="memdesc:a0f9dc60f3f6a8332b0ed727d4c8fd40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the FOLLOW set for a given non-terminal symbol in the grammar.  <br /></td></tr>
<tr class="separator:a0f9dc60f3f6a8332b0ed727d4c8fd40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5817b02a5ea7faa4480cb64ad31dd2" id="r_a5e5817b02a5ea7faa4480cb64ad31dd2"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e5817b02a5ea7faa4480cb64ad31dd2">PredictionSymbols</a> (const std::string &amp;antecedent, const std::vector&lt; std::string &gt; &amp;consequent)</td></tr>
<tr class="memdesc:a5e5817b02a5ea7faa4480cb64ad31dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the prediction symbols for a given production rule.  <br /></td></tr>
<tr class="separator:a5e5817b02a5ea7faa4480cb64ad31dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b33aead1b94c61884afb06f204fd3e4" id="r_a7b33aead1b94c61884afb06f204fd3e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b33aead1b94c61884afb06f204fd3e4">CreateLL1Table</a> ()</td></tr>
<tr class="memdesc:a7b33aead1b94c61884afb06f204fd3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the LL(1) parsing table for the grammar.  <br /></td></tr>
<tr class="separator:a7b33aead1b94c61884afb06f204fd3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cc4c090b6a32d97f5ed035da9cba9d" id="r_a00cc4c090b6a32d97f5ed035da9cba9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00cc4c090b6a32d97f5ed035da9cba9d">PrintTableUsingTabulate</a> ()</td></tr>
<tr class="memdesc:a00cc4c090b6a32d97f5ed035da9cba9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the LL(1) parsing table using the tabulate library.  <br /></td></tr>
<tr class="separator:a00cc4c090b6a32d97f5ed035da9cba9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4952d42125fbfc00daf0ce45a3532b0c" id="r_a4952d42125fbfc00daf0ce45a3532b0c"><td class="memItemLeft" align="right" valign="top"><a id="a4952d42125fbfc00daf0ce45a3532b0c" name="a4952d42125fbfc00daf0ce45a3532b0c"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kTraceSize</b> {5}</td></tr>
<tr class="memdesc:a4952d42125fbfc00daf0ce45a3532b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size limit for symbol history trace, defaults to 5. <br /></td></tr>
<tr class="separator:a4952d42125fbfc00daf0ce45a3532b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cba4eed3d7b262f17509779934f1fd" id="r_a29cba4eed3d7b262f17509779934f1fd"><td class="memItemLeft" align="right" valign="top"><a id="a29cba4eed3d7b262f17509779934f1fd" name="a29cba4eed3d7b262f17509779934f1fd"></a>
ll1_table&#160;</td><td class="memItemRight" valign="bottom"><b>ll1_t_</b></td></tr>
<tr class="memdesc:a29cba4eed3d7b262f17509779934f1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LL(1) parsing table, mapping non-terminals and terminals to productions. <br /></td></tr>
<tr class="separator:a29cba4eed3d7b262f17509779934f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8148d39b8f39a98b4210490346beb3b4" id="r_a8148d39b8f39a98b4210490346beb3b4"><td class="memItemLeft" align="right" valign="top"><a id="a8148d39b8f39a98b4210490346beb3b4" name="a8148d39b8f39a98b4210490346beb3b4"></a>
<a class="el" href="structGrammar.html">Grammar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gr_</b></td></tr>
<tr class="memdesc:a8148d39b8f39a98b4210490346beb3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structGrammar.html">Grammar</a> object associated with this parser. <br /></td></tr>
<tr class="separator:a8148d39b8f39a98b4210490346beb3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99111137eeeeb3d44b7b20417297df9b" id="r_a99111137eeeeb3d44b7b20417297df9b"><td class="memItemLeft" align="right" valign="top"><a id="a99111137eeeeb3d44b7b20417297df9b" name="a99111137eeeeb3d44b7b20417297df9b"></a>
std::unordered_map&lt; std::string, std::unordered_set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>first_sets_</b></td></tr>
<tr class="memdesc:a99111137eeeeb3d44b7b20417297df9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIRST sets for each non-terminal in the grammar. <br /></td></tr>
<tr class="separator:a99111137eeeeb3d44b7b20417297df9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faec5578f60af3641a5bb6bde66aa8f" id="r_a9faec5578f60af3641a5bb6bde66aa8f"><td class="memItemLeft" align="right" valign="top"><a id="a9faec5578f60af3641a5bb6bde66aa8f" name="a9faec5578f60af3641a5bb6bde66aa8f"></a>
std::unordered_map&lt; std::string, std::unordered_set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>follow_sets_</b></td></tr>
<tr class="memdesc:a9faec5578f60af3641a5bb6bde66aa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">FOLLOW sets for each non-terminal in the grammar. <br /></td></tr>
<tr class="separator:a9faec5578f60af3641a5bb6bde66aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc998981a7a6635e498d36954781aea0" id="r_adc998981a7a6635e498d36954781aea0"><td class="memItemLeft" align="right" valign="top"><a id="adc998981a7a6635e498d36954781aea0" name="adc998981a7a6635e498d36954781aea0"></a>
std::stack&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>symbol_stack_</b></td></tr>
<tr class="memdesc:adc998981a7a6635e498d36954781aea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack for managing parsing symbols. <br /></td></tr>
<tr class="separator:adc998981a7a6635e498d36954781aea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925dde74d4f9e5a40eeba14d10b08bbb" id="r_a925dde74d4f9e5a40eeba14d10b08bbb"><td class="memItemLeft" align="right" valign="top"><a id="a925dde74d4f9e5a40eeba14d10b08bbb" name="a925dde74d4f9e5a40eeba14d10b08bbb"></a>
std::deque&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>trace_</b></td></tr>
<tr class="memdesc:a925dde74d4f9e5a40eeba14d10b08bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deque for tracking the most recent kTraceSize symbols parsed. <br /></td></tr>
<tr class="separator:a925dde74d4f9e5a40eeba14d10b08bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d3b82775755d12b9f2c5a874efa365" id="r_a69d3b82775755d12b9f2c5a874efa365"><td class="memItemLeft" align="right" valign="top"><a id="a69d3b82775755d12b9f2c5a874efa365" name="a69d3b82775755d12b9f2c5a874efa365"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>grammar_file_</b></td></tr>
<tr class="memdesc:a69d3b82775755d12b9f2c5a874efa365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to the grammar file used in this parser. <br /></td></tr>
<tr class="separator:a69d3b82775755d12b9f2c5a874efa365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608a4c6bd4f7e3408f1e5edcc0faf30a" id="r_a608a4c6bd4f7e3408f1e5edcc0faf30a"><td class="memItemLeft" align="right" valign="top"><a id="a608a4c6bd4f7e3408f1e5edcc0faf30a" name="a608a4c6bd4f7e3408f1e5edcc0faf30a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>text_file_</b></td></tr>
<tr class="memdesc:a608a4c6bd4f7e3408f1e5edcc0faf30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to the input text file to be parsed. <br /></td></tr>
<tr class="separator:a608a4c6bd4f7e3408f1e5edcc0faf30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c0e1a3542584905c82e22156c35d92" id="r_a20c0e1a3542584905c82e22156c35d92"><td class="memItemLeft" align="right" valign="top"><a id="a20c0e1a3542584905c82e22156c35d92" name="a20c0e1a3542584905c82e22156c35d92"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>print_table_format_</b> {true}</td></tr>
<tr class="memdesc:a20c0e1a3542584905c82e22156c35d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if new format is used when printing the table. <br /></td></tr>
<tr class="separator:a20c0e1a3542584905c82e22156c35d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa240d93c411bc895acadcfdd7abd0320" name="aa240d93c411bc895acadcfdd7abd0320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa240d93c411bc895acadcfdd7abd0320">&#9670;&#160;</a></span>ll1_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using LL1Parser::ll1_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::unordered_map&lt;</div>
<div class="line">        std::string, std::unordered_map&lt;std::string, std::vector&lt;production&gt;&gt;&gt;</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a419899deba2324f6018dff5aa8f1c933" name="a419899deba2324f6018dff5aa8f1c933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419899deba2324f6018dff5aa8f1c933">&#9670;&#160;</a></span>LL1Parser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LL1Parser::LL1Parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGrammar.html">Grammar</a></td>          <td class="paramname"><span class="paramname"><em>gr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>text_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>table_format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classLL1Parser.html">LL1Parser</a> with a grammar object and an input file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gr</td><td><a class="el" href="structGrammar.html">Grammar</a> object to parse with. </td></tr>
    <tr><td class="paramname">text_file</td><td>Name of the file containing input to parse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a573b8200f9a1dce0e22caa9ea633c4a1" name="a573b8200f9a1dce0e22caa9ea633c4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573b8200f9a1dce0e22caa9ea633c4a1">&#9670;&#160;</a></span>LL1Parser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LL1Parser::LL1Parser </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>grammar_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>text_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>table_format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classLL1Parser.html">LL1Parser</a> with a grammar file and an input file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grammar_file</td><td>Path to the grammar file. </td></tr>
    <tr><td class="paramname">text_file</td><td>Name of the file containing input to parse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3644ed0d218effcaa8ac25ef329a5d5" name="ac3644ed0d218effcaa8ac25ef329a5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3644ed0d218effcaa8ac25ef329a5d5">&#9670;&#160;</a></span>LL1Parser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LL1Parser::LL1Parser </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>grammar_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>table_format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classLL1Parser.html">LL1Parser</a> with a grammar file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grammar_file</td><td>Path to the grammar file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f702d940802a8b02538cb173a6c7e5e" name="a2f702d940802a8b02538cb173a6c7e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f702d940802a8b02538cb173a6c7e5e">&#9670;&#160;</a></span>ComputeFirstSets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LL1Parser::ComputeFirstSets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the FIRST sets for all non-terminal symbols in the grammar. </p>
<p>This function calculates the FIRST set for each non-terminal symbol in the grammar by iteratively applying a least fixed-point algorithm. This approach ensures that the FIRST sets are fully populated by repeatedly expanding and updating the sets until no further changes occur (i.e., a fixed-point is reached). </p>

</div>
</div>
<a id="a02ee1f3ebc4cedacbb11204e3e8cbfdc" name="a02ee1f3ebc4cedacbb11204e3e8cbfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ee1f3ebc4cedacbb11204e3e8cbfdc">&#9670;&#160;</a></span>ComputeFollowSets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LL1Parser::ComputeFollowSets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the FOLLOW sets for all non-terminal symbols in the grammar. </p>
<p>The FOLLOW set of a non-terminal symbol A contains all terminal symbols that can appear immediately after A in any sentential form derived from the grammar's start symbol. Additionally, if A can be the last symbol in a derivation, the end-of-input marker (<code>$</code>) is included in its FOLLOW set.</p>
<p>This function computes the FOLLOW sets using the following rules:</p><ol type="1">
<li>Initialize FOLLOW(S) = { $ }, where S is the start symbol.</li>
<li>For each production rule of the form A → αBβ:<ul>
<li>Add FIRST(β) (excluding ε) to FOLLOW(B).</li>
<li>If ε ∈ FIRST(β), add FOLLOW(A) to FOLLOW(B).</li>
</ul>
</li>
<li>Repeat step 2 until no changes occur in any FOLLOW set.</li>
</ol>
<p>The computed FOLLOW sets are cached in the <code>follow_sets_</code> member variable for later use by the parser.</p>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the FIRST sets for all symbols have already been computed and are available in the <code>first_sets_</code> member variable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af556dd5a7357b97ec5d078983db62553" title="Calculates the FIRST set for a given production rule in a grammar.">First</a> </dd>
<dd>
<a class="el" href="#a9faec5578f60af3641a5bb6bde66aa8f" title="FOLLOW sets for each non-terminal in the grammar.">follow_sets_</a> </dd></dl>

</div>
</div>
<a id="a7b33aead1b94c61884afb06f204fd3e4" name="a7b33aead1b94c61884afb06f204fd3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b33aead1b94c61884afb06f204fd3e4">&#9670;&#160;</a></span>CreateLL1Table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LL1Parser::CreateLL1Table </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the LL(1) parsing table for the grammar. </p>
<p>This function constructs the LL(1) parsing table by iterating over each production in the grammar and determining the appropriate cells for each non-terminal and director symbol (prediction symbol) combination. If the grammar is LL(1) compatible, each cell will contain at most one production, indicating no conflicts. If conflicts are found, the function will return <code>false</code>, signaling that the grammar is not LL(1).</p>
<ul>
<li>For each production rule <code>A -&gt; α</code>, the function calculates the director symbols using the <code>director_symbols</code> function.</li>
<li>It then fills the parsing table at the cell corresponding to the non-terminal <code>A</code> and each director symbol in the set.</li>
<li>If a cell already contains a production, this indicates a conflict, meaning the grammar is not LL(1).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the table is created successfully, indicating the grammar is LL(1) compatible; <code>false</code> if any conflicts are detected, showing that the grammar does not meet LL(1) requirements. </dd></dl>

</div>
</div>
<a id="af556dd5a7357b97ec5d078983db62553" name="af556dd5a7357b97ec5d078983db62553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af556dd5a7357b97ec5d078983db62553">&#9670;&#160;</a></span>First()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LL1Parser::First </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>rule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the FIRST set for a given production rule in a grammar. </p>
<p>The FIRST set of a production rule contains all terminal symbols that can appear at the beginning of any string derived from that rule. If the rule can derive the empty string (epsilon), epsilon is included in the FIRST set.</p>
<p>This function computes the FIRST set by examining each symbol in the production rule:</p><ul>
<li>If a terminal symbol is encountered, it is added directly to the FIRST set, as it is the starting symbol of some derivation.</li>
<li>If a non-terminal symbol is encountered, its FIRST set is recursively computed and added to the result, excluding epsilon unless it is followed by another symbol that could also lead to epsilon.</li>
<li>If the entire rule could derive epsilon (i.e., each symbol in the rule can derive epsilon), then epsilon is added to the FIRST set.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule</td><td>A span of strings representing the production rule for which to compute the FIRST set. Each string in the span is a symbol (either terminal or non-terminal). </td></tr>
    <tr><td class="paramname">result</td><td>A reference to an unordered set of strings where the computed FIRST set will be stored. The set will contain all terminal symbols that can start derivations of the rule, and possibly epsilon if the rule can derive an empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f9dc60f3f6a8332b0ed727d4c8fd40f" name="a0f9dc60f3f6a8332b0ed727d4c8fd40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9dc60f3f6a8332b0ed727d4c8fd40f">&#9670;&#160;</a></span>Follow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::string &gt; LL1Parser::Follow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the FOLLOW set for a given non-terminal symbol in the grammar. </p>
<p>The FOLLOW set for a non-terminal symbol includes all symbols that can appear immediately to the right of that symbol in any derivation, as well as any end-of-input markers if the symbol can appear at the end of derivations. FOLLOW sets are used in LL(1) parsing table construction to determine possible continuations after a non-terminal.</p>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the follow sets for all symbols have already been computed by using ComputeFollowSets function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Non-terminal symbol for which to compute the FOLLOW set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered set of strings containing symbols that form the FOLLOW set for <code>arg</code>. </dd></dl>

</div>
</div>
<a id="a235e19d551647775130eddfd0661311b" name="a235e19d551647775130eddfd0661311b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235e19d551647775130eddfd0661311b">&#9670;&#160;</a></span>MatchTerminal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LL1Parser::MatchTerminal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>top_symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>current_symbol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a terminal symbol from the stack with the current input symbol. </p>
<p>This function compares the terminal symbol at the top of the stack with the current input symbol. If they match, it updates the parsing trace (<code>trace_</code>), consumes the current input symbol, and retrieves the next input symbol using the lexical analyzer (<code>lex</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_symbol</td><td>The terminal symbol popped from the top of the stack. </td></tr>
    <tr><td class="paramname">current_symbol</td><td>The current input symbol to be matched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the terminal symbol matches the current input symbol, false otherwise. </dd></dl>

</div>
</div>
<a id="a658cc49bf42de998962dba95c06ee2ab" name="a658cc49bf42de998962dba95c06ee2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658cc49bf42de998962dba95c06ee2ab">&#9670;&#160;</a></span>Parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LL1Parser::Parse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an input string or file using the LL(1) parsing algorithm. </p>
<p>This function performs syntactic analysis on the input based on the LL(1) parsing table, working to validate whether the input string conforms to the grammar. The parsing process involves a stack-based approach, where:</p>
<ul>
<li>The function initializes a stack with the starting symbol of the grammar.</li>
<li>For each symbol in the input, it matches and expands according to the entries in the LL(1) parsing table.</li>
<li>If a match is found for the current input symbol and top of the stack, the function advances in the input and continues parsing.</li>
<li>If a production rule applies, it expands the non-terminal on the stack using the rule.</li>
<li>If an unexpected symbol or parsing conflict arises, the function returns <code>false</code>, indicating that the input does not conform to the grammar.</li>
</ul>
<p>The function returns <code>true</code> if parsing completes successfully, reaching the end of the input and stack without errors. Otherwise, it returns <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the input is parsed successfully, meaning it conforms to the LL(1) grammar; <code>false</code> if parsing fails due to a mismatch, conflict, or unexpected input symbol. </dd></dl>

</div>
</div>
<a id="a5e5817b02a5ea7faa4480cb64ad31dd2" name="a5e5817b02a5ea7faa4480cb64ad31dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5817b02a5ea7faa4480cb64ad31dd2">&#9670;&#160;</a></span>PredictionSymbols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::string &gt; LL1Parser::PredictionSymbols </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>antecedent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consequent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the prediction symbols for a given production rule. </p>
<p>The prediction symbols for a rule, determine the set of input symbols that can trigger this rule in the parsing table. This function calculates the prediction symbols based on the FIRST set of the consequent and, if epsilon (the empty symbol) is in the FIRST set, also includes the FOLLOW set of the antecedent.</p>
<ul>
<li>If the FIRST set of the consequent does not contain epsilon, the prediction symbols are simply the FIRST symbols of the consequent.</li>
<li>If the FIRST set of the consequent contains epsilon, the prediction symbols are computed as (FIRST(consequent) - {epsilon}) ∪ FOLLOW(antecedent).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">antecedent</td><td>The left-hand side non-terminal symbol of the rule. </td></tr>
    <tr><td class="paramname">consequent</td><td>A vector of symbols on the right-hand side of the rule (production body). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered set of strings containing the prediction symbols for the specified rule. </dd></dl>

</div>
</div>
<a id="aa1b0f4b5c16280855395a00acab8489c" name="aa1b0f4b5c16280855395a00acab8489c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b0f4b5c16280855395a00acab8489c">&#9670;&#160;</a></span>PrintStackTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LL1Parser::PrintStackTrace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the remaining symbols in the parsing stack after the parsing process. </p>
<p>This function outputs the contents of the parsing stack to standard output after the parsing attempt completes, showing any symbols left unresolved. It is useful for debugging and tracing parsing issues, as it provides insight into where the parsing process may have diverged from expected behavior. </p>

</div>
</div>
<a id="a5975f1abae5c7a04e01d239bef27a0eb" name="a5975f1abae5c7a04e01d239bef27a0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5975f1abae5c7a04e01d239bef27a0eb">&#9670;&#160;</a></span>PrintSymbolHist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LL1Parser::PrintSymbolHist </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the last kTraceSize symbols processed. </p>
<p>Primarily used to identify the most recent tokens processed in case of parsing errors. </p>

</div>
</div>
<a id="a964e6f48a2941f4925dd65f63f5123ca" name="a964e6f48a2941f4925dd65f63f5123ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964e6f48a2941f4925dd65f63f5123ca">&#9670;&#160;</a></span>PrintTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LL1Parser::PrintTable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the LL(1) parsing table to standard output. </p>
<p>Displays the LL(1) table for debugging and analysis. The output format depends on the value of <code>print_table_format_</code>:</p><ul>
<li>If <code>print_table_format_</code> is <code>true</code>, the table is printed using the <code>tabulate</code> library for a structured and visually enhanced output.</li>
<li>If <code>print_table_format_</code> is <code>false</code>, the table is printed in a simpler text format. </li>
</ul>

</div>
</div>
<a id="a00cc4c090b6a32d97f5ed035da9cba9d" name="a00cc4c090b6a32d97f5ed035da9cba9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cc4c090b6a32d97f5ed035da9cba9d">&#9670;&#160;</a></span>PrintTableUsingTabulate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LL1Parser::PrintTableUsingTabulate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the LL(1) parsing table using the tabulate library. </p>
<p>This function generates a structured LL(1) table using the <code>tabulate</code> library, displaying non-terminals as row headers and terminal symbols as columns. Productions are formatted within the table cells. The table uses:</p><ul>
<li>Bold, centered headers with yellow font color.</li>
<li>Cyan font color for the first column (non-terminals).</li>
<li>Red font color for cells containing multiple productions (conflicts).</li>
<li>A visually structured alignment for improved readability. </li>
</ul>

</div>
</div>
<a id="aed1fa3255a089e2fa52a11b015490975" name="aed1fa3255a089e2fa52a11b015490975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1fa3255a089e2fa52a11b015490975">&#9670;&#160;</a></span>ProcessNonTerminal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LL1Parser::ProcessNonTerminal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>top_symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>current_symbol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes a non-terminal symbol by expanding it according to the LL(1) parsing table. </p>
<p>This function looks up the production rule in the LL(1) parsing table (<code>ll1_t_</code>) for the given non-terminal symbol and current input symbol. If a matching production is found, the production's symbols are pushed onto the stack in reverse order.</p>
<p>If no matching production is found, it checks whether the grammar allows an empty production for the non-terminal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_symbol</td><td>The non-terminal symbol popped from the top of the stack. </td></tr>
    <tr><td class="paramname">current_symbol</td><td>The current input symbol used to select a production.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a production was successfully applied or an empty production exists, false if no valid production exists for the current input. </dd></dl>

</div>
</div>
<a id="a44706610e5fad3f4d2fd437f64c8884b" name="a44706610e5fad3f4d2fd437f64c8884b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44706610e5fad3f4d2fd437f64c8884b">&#9670;&#160;</a></span>UpdateFollow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LL1Parser::UpdateFollow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const production &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the FOLLOW set for a non-terminal based on a production. </p>
<p>This method updates the FOLLOW set of a given non-terminal symbol based on its position within a production. It considers:</p><ul>
<li>The FIRST set of the remaining symbols after the current non-terminal.</li>
<li>The FOLLOW set of the left-hand side non-terminal, if the remaining symbols can derive ε.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The non-terminal symbol whose FOLLOW set is being updated. </td></tr>
    <tr><td class="paramname">lhs</td><td>The left-hand side non-terminal of the current production. </td></tr>
    <tr><td class="paramname">rhs</td><td>The production (right-hand side) containing the symbol. </td></tr>
    <tr><td class="paramname">i</td><td>The position of the symbol within the production.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the FOLLOW set was modified (new elements were added), false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="ll1__parser_8hpp_source.html">ll1_parser.hpp</a></li>
<li>src/<b>ll1_parser.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
